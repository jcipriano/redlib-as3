package org.redblind.flartoolkit {	import flash.display.Sprite;		import flash.geom.Point;		import flash.geom.Matrix;		import flash.display.DisplayObject;			import org.libspark.flartoolkit.core.transmat.FLARTransMatResult;	import org.libspark.flartoolkit.pv3d.FLARCamera3D;		import org.libspark.flartoolkit.core.raster.rgb.FLARRgbRaster_BitmapData;		import org.libspark.flartoolkit.detector.FLARSingleMarkerDetector;	import org.libspark.flartoolkit.core.param.FLARParam;		import org.libspark.flartoolkit.core.FLARCode;			import org.papervision3d.scenes.Scene3D;		import org.papervision3d.render.BasicRenderEngine;		import org.papervision3d.view.Viewport3D;			import flash.display.BitmapData;	import flash.media.Video;		import flash.media.Camera;	import flash.net.URLLoader;		import flash.net.URLLoaderDataFormat;		import flash.events.SecurityErrorEvent;		import flash.events.IOErrorEvent;		import flash.events.Event;		import flash.net.URLRequest;			import org.redblind.pv3d.BaseScene3D;		/**	 * FlarBase is an extendable class that manages a very basic FlarToolKit environment.	 * It decouples the FlarToolKit setup from the creation and management of the Papervision3D environment.	 * Extends BaseScene3DFlash, so the FlarToolKit and Papervsion3D setup is automatically handled.	 */	public class FlarBase extends BaseScene3D 	{		private var dl:URLLoader;		private var fp:FLARParam;		private var fc:FLARCode;		private var rd:FLARRgbRaster_BitmapData;		private var md:FLARSingleMarkerDetector;				private var cameraDataURL:URLRequest;		private var codeDataURL:URLRequest;				private var cam:Camera;		private var vid:Video;		private var vidHolder:Sprite;		private var bmd:BitmapData;		private var vpWidth:Number;		private var vpHeight:Number;		private var cWidth:Number;		private var fps:int;				public var flar3D:FlarObject3D;		    	private var fcam:FLARCamera3D;		private var ftm:FLARTransMatResult;		private var offsetX:Number;		private var offsetY:Number;		private var flarScale:Number;				public var markerDetected:Boolean;		public var maxFailedAtempts:int = 20;		private var failedAttempts:int = 0;				public var confidence:Number;				/**		 * Initializes the FlarToolKit and Papervision3D environement.		 * @param 	cameraData		URLRequest to the camera data file.		 * @param 	codeData		URLRequest to the code/marker data file.		 * @param 	width			Width of the video display and Papervision3D viewport.		 * @param 	height			Height of the video display and Papervision3D viewport.		 * @param 	codeWidth		The width of the marker image in reference the Papervision3D scene.		 * @param	fps				Frames per second of the video from webcam.		 * @param 	offsetX			The amount to offset the Papervision3D scene on the X axis.		 * @param 	offsetY			The amount to offset the Papervision3D scene on the Y axis.		 * @param 	scale			The scale of the Papervision3D viewport.		 * @param 	confidence		The confidene level (0-1) that the marker detection should have before determining a successful detection.		 */		public function init(cameraData:URLRequest,codeData:URLRequest,width:Number=640,height:Number=480,codeWidth:int=80,fps:int=30,offsetX:Number=0,offsetY:Number=0,scale:Number=2,confidence:Number=0.75):void		{			this.cameraDataURL = cameraData;			this.codeDataURL = codeData;						this.flarScale = scale;			this.vpWidth = width;			this.vpHeight = height;			this.cWidth = codeWidth;			this.fps = fps;						this.offsetX = offsetX;			this.offsetY = offsetY;						this.confidence = confidence;						dl = new URLLoader();			dl.addEventListener(IOErrorEvent.IO_ERROR,dispatchEvent);			dl.addEventListener(SecurityErrorEvent.SECURITY_ERROR,dispatchEvent);						loadCameraData();		}		private function loadCameraData():void		{			dl.addEventListener(Event.COMPLETE,cameraDataComplete);			dl.dataFormat = URLLoaderDataFormat.BINARY;			dl.load(cameraDataURL);		}				private function cameraDataComplete(e:Event):void		{			dl.removeEventListener(Event.COMPLETE,cameraDataComplete);						fp = new FLARParam();			fp.loadARParam(dl.data);			fp.changeScreenSize(vpWidth,vpHeight);						loadCodeData();		}		private function loadCodeData():void		{			dl.addEventListener(Event.COMPLETE,codeDataComplete);			dl.dataFormat = URLLoaderDataFormat.TEXT;			dl.load(codeDataURL);		}				private function codeDataComplete(e:Event):void		{			dl.removeEventListener(Event.COMPLETE,codeDataComplete);			fc = new FLARCode(16,16);			fc.loadARPatt(dl.data);						setup();		}				private function setup():void		{			dl.removeEventListener(IOErrorEvent.IO_ERROR,dispatchEvent);			dl.removeEventListener(SecurityErrorEvent.SECURITY_ERROR,dispatchEvent);			dl = null;						cam = Camera.getCamera();			if(!cam) {				this.dispatchEvent(new Event('NO_CAMERA_DETECTED',true));				return;			}			cam.setMode(vpWidth,vpHeight,fps,false);						vid = new Video();			vid.width = vpWidth;			vid.height = vpHeight;			vid.attachCamera(cam);			mirrorVid();						vidHolder = new Sprite();			addChild(vidHolder);			vidHolder.addChild(vid);						bmd = new BitmapData(vpWidth,vpHeight,false);			bmd.draw(vidHolder);						rd = new FLARRgbRaster_BitmapData(bmd);			md = new FLARSingleMarkerDetector(fp,fc,cWidth);						createScene(vpWidth,vpHeight,false,false);		}				public function setScreen(object:DisplayObject):void		{			addChild(object);		}				override protected function createScene(viewportWidth:Number=640,viewportHeight:Number=480,isAutoScaleToStage:Boolean=false,isInteractive:Boolean=true):void		{			viewport = new Viewport3D(viewportWidth,viewportHeight,isAutoScaleToStage,isInteractive,false);			viewport.scaleX = viewport.scaleY = flarScale;			viewport.x = offsetX;			viewport.y = offsetY;			addChild(viewport);			            scene = new Scene3D();  			fcam = new FLARCamera3D(fp);  			renderer = new BasicRenderEngine();                        flar3D = new FlarObject3D();			scene.addChild(flar3D);                        ftm = new FLARTransMatResult();			            addEventListener(Event.ENTER_FRAME, detectMarker);            createObjects();		}				override protected function handleRenderInterval(e:Event):void		{			renderer.renderScene(scene,fcam,viewport);			for each(var method:Function in renderMethods){ method(); }		}				private function detectMarker(e:Event):void		{			bmd.draw(vidHolder);			try{				if(md.detectMarkerLite(rd,cWidth) && md.getConfidence()>confidence){					failedAttempts = 0;					md.getTransformMatrix(ftm);					if(!markerDetected){						dispatchEvent(new Event('DETECTION_SUCCESS'));						flar3D.forceTransformMatrix(ftm);					}else{						flar3D.setTransformMatrix(ftm);					}					markerDetected = true;				}else{					failedAttempts++;					if(failedAttempts==maxFailedAtempts){						if(markerDetected) dispatchEvent(new Event('DETECTION_FAILURE'));						markerDetected = false;					}				}			}catch(e:Error){				trace(e);			}		}				private function mirrorVid():void		{			var matrix:Matrix = vid.transform.matrix;			matrix.transformPoint(new Point(vid.width/2,vid.height/2));			matrix.a = -1*matrix.a;			matrix.tx = vid.width+vid.x;			vid.transform.matrix = matrix;		}	}}